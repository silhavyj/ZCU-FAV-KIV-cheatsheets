## 01_02

- historie (generace PC, mooruv zakon)
- logicke obvody (digital vs analog, kombinacni vs sekvencni, popis, hradla, bloky, charakteristika)
- booleovska logika, hazardy
- zobrazeni cisel (zakladni zapis cisel, pozicni system)
  - primy kod, inverzni kod, doplnkovy kod, IEEE754
- ALU (popis, vstupy, vystypu, overflow, carry, zero, control, ...)
- HA, FA, FU ze dvou HA
- RCA (zpozdeni, generace, propagace, anihilace)
- paralelni asynchronni sumator
- CLA (odvozeni, vyhody & nevyhody, zpozdeni, serializace CLA, stromova struktura)
- Carry-Skip Adder (propagace vs vypocet, promenne delky bloku)
- Carry-Select Adder (vypocetni slozitost, plocha, velikost bloku, vyhody & nevyhody)
- CIA (Carry-Inc Adder) (vylepseni Carry-Select Adder, vyuziti P,G signalu => vyber vysledku pre XOR)
- odcitacka (dvojkovy doplnek -> +1 realizovano pres Cin = 1)
- seriova scitacka
- citace
  - straight ring counter (manual set 1 pomoci reset)
  - twisted ring counter

## 03

- typy metod nasobeni (sekvencni, paralelni - iteracni aritmeticka pole, specialni kodovani)
- posuvne jednotku (paralel/serial IO, smer, pocet kroku)
  - univerzalni posuvny registr
  - Barrel Shifter
  - Posivna jednotka multiplexerem
  - logaritmicka posuvna jednotka
  - posuvna matice
- parcialni souciny (nasobenec, nasobitel, ...)
- viceoperandove scitani (registr parcialniho souctu, volba typu scitacky, superlinerni vs logaritmicky narust casove slozitosti s `n` a `k`)
- vytvareni parcialniho soucinu
  - zpozdeni nlog(n), posun vlevo vs posun vpravo + soucet (=> sirka scitacky)
- seriova scitacka (princip - blokove schema)
  - akcelerace pouzitim vetsiho poctu scitacek (generujeme vicero paracialnich soucinu naraz -> pouziti vice scitacek seriove)
  - odstraneni serioveho zapojeni (nevyhoda) => vicevstupove scitacky, stromove zapojeni (HW narocne)
- nasobeni zapornych cisel
  - zaporny nasobenec (expanze sign bitu)
  - zaporny nasobitel (odecteni korekcniho clenu (-A))
  - => nevyhoda epanze znamenkoveho bitu (hodne scitani 1)
- boothuv algoritmus - (2,1); (3,2); (4;3) ; s vetsim posunem redukuje pocet parcialnich soucinu
  - lze uplatnit i pro nasobeni s jinym zakladem nez 2 (napr 4) => lepsi je provest prekodovani abychom pouzivali cifry co jsou mocninou 2 (napr {0,1,2,3} -> {-2,-1,0,1,2})
  - odvozeni dle YT videa
- paralelni algoritmy nasobeni
  - redukce pomoci paralelnich dilcich nasobicek (3,2) - FA, (5,5,4)
  - redukcni posloupnost
- Carry-Save Adder = (3,2) redukce
- Wallace nasobicka
- iteracni aritmeticka pole
  - naivni postup
  - cile uprav
  - Baugh-Wooley nasobicka (+ schema s negaci MSB)
  - generovani elementarnich soucinu uvnitr pole (sireni cary, delka kriticke cesty)
    - struktura jedne bunky nasobicky (muze implementovat vicero funkci)
  - piplining
  - pole pro nasobeni s carry-save-adder

## 04

- moznosti implementace delicek (odcitani, newton, deleni konstantou, prevod do log systemu)
- LNS (log2(|X|))
- RNS (+ zaporna cisla, vyhody, nevyhody - deleni obtizne, porovnani je slozite protoze neni pozicni, ucinnost)
- MRS (je pozicni -> jednoduche porovnani; priklad (0,2,2)RMS(5,3))
- ciselny system se zapornym zakladem
  - suda pozice +, licha - (zacina se od 0)
  - rozsahy oboru hodnot v zavislosti na poctu cislic, prenos carry, nevyhoda math. operaci, aplikace zpracovani signalu
- ciselne systemy s ciframi se znamenkem
  - symetricke vs nesymetricke rozlozeni kolem 0
  - algoritmus prevodu {0,1,2,3} -> {-1,0,1,2}
  - algoritmus prevodu [0,3] -> [-2,2] = [-2,1] + [0,1] (dekompozice? "carry free")
- moznosti jak se vyporadat s dlohou prenosovou cestou (detekce ukonceni, CLA, rozsireni poctu bitu vysledku?)
- scitani cisel s redundanci (dekompozice)
  - scitani dvou cisel z [0,18] nam da vysledek [0,36]. My ale chceme vysledek z [0,18] => soupnuti o rad [0,18] -> [0,2] + [0,16]
  - [0,11] -> [0,9] + [0,2] (scitani cisel o zakladu 10 v mnozine cifer [0,11])
- index redundance: `idx = -A+B+1-r`

## 05

- typy kanalu (s pameti - shluky chyb, bez pameti - nezavisle chyby)
- kod (symetricky vs nesymetricky, jednosmerny, blokovy, systematicky vs nesystematicky)
- hammingova vzdalenost
- jednotuche kody
  - opakovaci
  - koktavy
  - parita (licha vs suda - XOR 1); detekce jednoduche chyby bez moznosti opravy; implementace pomoci Moorovo a Mealyho automatu (rozdil mezi nima?)
    - podelna, pricna parita (hamm. vzdalenost = 4 -> detekce az 3 a oprava 1 chyby)
  - checksum (soucet) - nevyhody 0, poradi
  - fletcher checksum (1 byty, modulo 255)
- hamminguv kod
  - 2^r-1 az 2^r-1-r kde r je jedundance
  - generujici matice, kontrolni matice
  - priklad (7,4)
    - hammingova vzdalenost = 3 (detekce dvou oprava max 1 chyby)
    - vypocet paritnich bitu, HW zapojeni
  - rozsireny haminguv kod (pridani parity)
- ECC vs EDC, SRAM vs DRAM, NAND flash layout
- CRC kody

## 06

- ISA (mechanismus SW rika HW co delat, co definuj dobre rozhrani, efektivita HW + abstrakce SW)
  - otazky pri navrhu instrukcni sady
  - pevna vs promenna delka instrukci (vyhody & nevyhody)
  - vyhody velkeho vs maleho poctu registru
  - architektury z pohledu kde jsou ulozene operandy (vyhody + nevyhody)
    - zasobnikova, ACC, memory-memory, register-memory, load-store
    - ortogonalita ISA
- vyhody a neyvhody pouzivani registru
- adresace pameti (word, big endian vs little endian)
- typy adresnich modu
  - direct register, immediate, offset (displacement), index, indirect register, direct memory, indirect memory, auto inc, auto dec, scaled
  - navic vyjimky kdy se adresuje PC
- typy instrukci (aritmeticko-logicke, data transfer, control, system, floating point, string, graphics)
- formaty instrukci (MIPS r, i, j)
- podmineny skok (relativni vuci PC, cykly, pole, ...)
- paralelni systemy
  - grid computing, cluster computing, SMP, multi-core CPU
  - flynnova taxonomie
  - pamet paralelnich systemu (distribuovana vs sdilena - IPC)
    - SMP, NUMA (obrazky, vyhody, nevyhody), + interconnect
- logicky vs fyzicky adresni prostor (L=F, L>F, L<F)
- segmentace (code, data, zasobnik, ...)
- strankovani (algoritmy vyhazovani stranek)
- SRAM vs DRAM (nutnost ECC)
- sbernice (datova, adresni, ridici)
- cache
  - casova vs prostorova lokalita dat
  - propis do hlavni pameti (primi zapis, zapis s mezipameti, zpetny zapis, zpetny zapis pouze jiz propsaneho)
  - velikost bloku, hit rate, isntrukcni vs datova cache
  - info ulozene v cache: data, adresa, dirty bit, info o pouziti polozky
  - algoritmy invalidace cache zaznamu: random, FIFO, LRU, MFU, ..., razeni cachi
  - plne asociativni cache
  - cache s primym mapovanim
  - N-cestna cache

## 07

- mikroarchitektura (= implementace ISA)
  - popis radice mikroinstrukci/mikroprogramoveho automatu (vystupni signaly, stavy ridicich jednotek)
  - synchronni vs asynchronni automaty
  - Mealyho vs Mooruv automat
- vyhody mikroprogramoveho rizeni (=> imlementace rozsahle isntrukcni sady)
- mapovani ISA do architektury
- slozitost firmware - mikroskopicka slozitost a optimalizace vs strojove nezavisly model
- zakladni pojmy: mikrooperace, mikroinstrukce, mikroprogram, firmware
- 2 velke skupiny vystupnich signalu
- mikroinstrukcni pole (co obsahuje mikroinstrukce + nasledujici adresa)
- rekukce kapacity ridici pameti (rychlost vs kapacita)
  - nanoprogramovani (-> 2 mensi pameti - pointer na vystupni pole -> redukce sirky mikroinstrukce)
- priklad mikroarchitektury CPU (MIC-1)
  - MAR, MDR, PC, MBR, H, SP, TOS, B-bus, C-bus
  - mapovani MAR na sbernici (posun `<< 2`)
  - format instrukci MIC-1: addr, JAM (zpusob vyberu pristi addr), ALU, C, Mem, B
  - pridani latch registru na IO ALU => pipelining
- horizontalni vs vertikalni mikrokod

## 08

- vyhody seriove sbernice (delka, mene kabelu, ...)
- seriova vs parlaleni sbernice (clockskew, crosstalk, ...)
- parametry komunikace (protokol, pocet draru, synchronizace, napetove urovne, differencialni, halfduplex, atd.)
- RS232 (UART)
  - norma zahrnuje i handshakove signaly
  - baudrate (1200,2400,4800,9600,115200)
- RS485 (robustni UART)
  - prumyslove prostredu
  - kroucena dvojlika, rozdilove napeti, terminatory
- CAN
  - 11 vs 29 ID, arbitrace
  - struktura ramce: ID, CNTL, DATA, CRC, EOF
- I2C
  - SCL, SDA; SDA se meni pouze pokud SCL == low (vyjimka: START, STOP)
  - struktura ramce: START, 7-bit ADDR, RW, DATA, STOP
  - pokazdych 8 bitech => prijem ACK
  - detekce kolize: kontrola aktualniho stavu sbernice a aktulne vysilane hodnoty => musi byt stejne
  - broadcast: 0b0000000
- SPI: MISO, MOSI, CLK, CS
- 1 Wire (morseovka?)
  - nizke datove rychlosti
  - unikatni 48 ID
  - master
    - vysilani 1 = kratky puls
    - vysilani 0 = dlouhy puls
  - slave
    - vysilani 1 = nedela nic
    - vysilani 0 = stahne sbernici na 0
  - zakladni sekvence: puls (init), prikaz, a pak odesilani nebo prijimani dat
- USB (jednotne nahrazeni starsich standardu jako RS232)
  - point-to-point (master/slave)
  - vicero zarizeni pres HUB (az 5 urovni zanoreni)
  - komplexni, funguje na zaklade packetu (1. packet = token - typ prenosu, smer, cilove zarizeni)
  - transfer dat pres pipe (viz Linux)
  - rozdilove napetim halfduples, ID pridelovani dynamicky, vestavene CRC
  - 4 typy prenosu: control, bulk, int, izochronni
  - VID/PID
- startsi typ sbernice (PCI bridge mezi CPU a mem)
- novy typ sbernice centralni bridge (north/south)
  - => sbernici lze provozovat pri ruznych rychlostech (north - fast, south - slow)
- backplane sbernice
- dvousbernicovy system
- trisbernicovy system
- synchronni vs asynchronni sbernice
  - synchroni: muze nastat skew pri dlouhych vzdalenostech, kazde zarizeni musi podporovat danou rychlost
  - asynchronni: skew nemuze nastat, musi obsahovat handshake
- arbitrace: nejjednoduseni odstraneni chaosu -> zavedeni mastera (ale musi byt soucasti kazde transakce)
  - arbitrcni schema daisy chain (zadost, grant, uvolneni); rizeni pres arbitr
- IO mapovany do pametoveho prostoru (polling vs interrupt)
- princip DMA (master na sbernici)
- PCI (peripheral component interconnect)
  - rychle PCU ale i obsluha pomalych IO
  - backside bus vs frontside bus
  - pristup k systemove pameti pro pripojena zarizeni
  - pripojeni PCI k south bridge (PCIe k north)
- PCI (pokracovani)
  - multimaster, nezavislost na CPU, paralelni prenosy dat, 3 adresni prostory, dynamicke nastaveni frekvence hodin
  - iniciator, target, agent, funkce
  - burst rezim: adresni face + datova faze
  - jedno funkci vs multifunkcni zarizeni (kazda funkce => vlastni konfigurovatelny adresni prostor = registry)
  - adresni faze
    - cilova adresa + typ transakce (vice zarizeni se muze ucastnit dane transakce)
    - aktivace FRAME# signalu
    - pokud se zarizeni chce zucastnit -> nastavi signal DEVSEL#
  - datove faze
    - pocet bytu v jedne polozce je dan signalem Command/Byte Enable
    - celkovy pocet polozek neni znam -> pouziti IRDY# a TRDY# signalu
    - posledni datova faze zakoncena IRDY# = 1 a FRAME# = 0
  - signaly PCI: CLK#, RST#, FRAME#, IRDY#, TRDY#, STOP# (target konec), DEVSEL#, IDSEL# (konfigurace individualnich zarizeni na zacatku)
  - adresni a datove signaly: AD[31:0] - little endian, C/BE (prikazy PCI - cteni z IO prostoru, zapis do konfiguracniho prostoru, atd.), PAR (paritni bit)
  - chybove signaly (parity error, system error)
  - arcbitracni signaly REQ#, GNT# (pridelen iniciatoru arbitrem)
  - centralni arbitracni schema
  - normal (kazde dato ma adresu) vd burst mode (start adresa + sekvence dat)
  - vyznam cekajicich stavu (target oddeluje jednotlive datove polozky - cteni dat z targetu)
  - adresni prostory targetu PCI
    - konfiguracni (registry, nastaveni, typicky pres BIOS - zjistovani dostupnosti zarizni, konfigurace rychlosti, ...)
    - IO - specialni instrukce - in out (mapuji se sem klavenice, seriove porty, atd)
    - pametovy (pristup pomoci obecne instrukce CPU - mov, ld, str, ...)
  - plug and play (PNP)
    - karty musi obsahovat zakladni info pro BIOS
  - vyuziva odrazu signalu
- PCIe
  - vykon CPU se zdvojnasobuje kazdych 18 mesicu ale sberice jednou za 3 roky => zavedeni PCIe
  - seriove, point-to-point
  - rozdilove napeti, fullduplex, vysoke narocky na rychlost, rozsiritelnost (pridanim dalsiho zarizeni -> zvetsni sirky pasma)
  - neni potreba arbiter => point to point spojeni
  - link (= spoj mezi PCIe zarizenima); lane (= dvojice vodicu -> diferencialni napeti)
  - root complex
  - pozadavky na PCIe mohou jit pres prostredniku (z root complex pres switch do endpoint zarizeni)
  - zalozen na packetech (built in checky na ruznych vrstvach zapouzdreni)
